sed -n '/^COPY claimsprocess_humana.claim_core (/,/^\.$/p' claimsprocess_humana_12012025_data_ddl.sql > claim_core_only.sql

cat user|sed "s/^/'/; s/$/'/"

cat lumilist|sed "s/.*/'&'/g"

grep -irl "log_duration" * | grep yaml | xargs sed -i '' -E '/- option: log_duration/{n;N;s/\n[[:space:]]*value: off//;}' 

grep -irl "log_duration" * | grep yaml | xargs sed -n -E '/log_duration/{n;s/(value:)[[:space:]]*on/\1 off/p;}'

grep -irl "log_min_duration_statement" * | grep yaml | xargs sed -i '' -E '/log_min_duration_statement/{n;s/(value:)[[:space:]]*0/\1 100/;}'

sed 's/[ \t]*$//' a
above remove the line contains either space or tab only


Yes! `sed` supports several commands that work with the `/pattern/command` style â€” meaning: **"if a line matches this pattern, do this command."** It's a very powerful pattern-action model.

---

### ðŸ”§ Common `sed` Commands Using `/pattern/command` Style:

Here's a list of `sed` commands that can be paired with patterns:

---

#### âœ… `d` â€” Delete lines

```bash
sed '/^#/d' file.txt   # Delete lines that start with "#"
```

---

#### âœ… `p` â€” Print lines

```bash
sed -n '/error/p' file.log  # Print only lines containing "error"
```

> The `-n` option tells `sed` to **suppress automatic printing** â€” so only the `p` command explicitly prints lines.

---

#### âœ… `s` â€” Substitute (can also be conditional)

```bash
sed '/foo/s/bar/baz/' file.txt
```

> Only lines containing `foo` will have `bar` replaced with `baz`.

---

#### âœ… `a` â€” Append after a matching line

```bash
sed '/pattern/a\New line here' file.txt
```

---

#### âœ… `i` â€” Insert before a matching line

```bash
sed '/pattern/i\Header line' file.txt
```

---

#### âœ… `c` â€” Change the matching line to something else

```bash
sed '/pattern/c\This line was replaced' file.txt
```

---

#### âœ… `q` â€” Quit when a pattern matches

```bash
sed '/STOP/q' file.txt
```

> Stops reading the file once a line containing "STOP" is found.

---

#### âœ… `=` â€” Print line number

```bash
sed '/ERROR/=' file.txt
```

> Prints the line number for lines that contain "ERROR".

---

### ðŸ” You can also use **address ranges**:

```bash
sed '/START/,/END/d' file.txt
```

> Deletes all lines between and including "START" and "END".

---

### ðŸ”§ Combining Multiple Commands

```bash
sed '/pattern/{
  s/foo/bar/
  i\Inserted before match
  a\Appended after match
}' file.txt
```

---

### âœ… Summary

In `sed`, the pattern/command style (`/pattern/command`) applies to many commands:

* `d`, `p`, `s`, `a`, `i`, `c`, `q`, `=`, etc.

They're super flexible for filtering and transforming text based on patterns.

Let me know if you want cheat-sheet-style examples or multi-line editing tricks!

