-- Run this query in a separate session while your ALTER TABLE is hanging.
-- It identifies sessions (PIDs) that are currently blocking other sessions.

SELECT
-- Blocking Session Info (Details about the session holding the lock)
B.pid AS blocking_pid,
BlockingActivity.usename AS blocking_user,
BlockingActivity.client_addr AS blocking_client,
BlockingActivity.application_name AS blocking_app,
BlockingActivity.query AS blocking_query,
AGE(NOW(), BlockingActivity.query_start) AS blocking_duration,
-- Blocked Session Info (Details about the session waiting for the lock, where your ALTER TABLE should appear)
L.pid AS blocked_pid,
BlockedActivity.usename AS blocked_user,
pg_class.relname AS blocked_table,
BlockedActivity.query AS blocked_query,
-- Lock Details
L.mode AS blocked_lock_type,
B.mode AS blocking_lock_type
FROM
pg_catalog.pg_locks L
JOIN
pg_catalog.pg_stat_activity BlockedActivity ON L.pid = BlockedActivity.pid -- Get activity details for the waiting session (L)
JOIN
pg_catalog.pg_locks B ON B.locktype = L.locktype
AND B.database IS NOT DISTINCT FROM L.database
AND B.relation IS NOT DISTINCT FROM L.relation
AND B.page IS NOT DISTINCT FROM L.page
AND B.tuple IS NOT DISTINCT FROM L.tuple
AND B.virtualxid IS NOT DISTINCT FROM L.virtualxid
AND B.transactionid IS NOT DISTINCT FROM L.transactionid
AND B.classid IS NOT DISTINCT FROM L.classid
AND B.objid IS NOT DISTINCT FROM L.objid
AND B.objsubid IS NOT DISTINCT FROM L.objsubid
AND B.pid != L.pid -- Exclude self-blocking
JOIN
pg_catalog.pg_stat_activity BlockingActivity ON B.pid = BlockingActivity.pid -- Get activity details for the blocking session (B)
LEFT JOIN
pg_class ON pg_class.oid = L.relation -- Optional join to get table name (only if the lock is on a table/relation)
WHERE
L.granted = 'f' -- Find only waiting/blocked queries
ORDER BY
blocking_duration DESC;


SELECT 
    l.locktype,
    l.database,
    l.relation,
    l.page,
    l.tuple,
    l.virtualxid,
    l.pid,
    l.mode,
    l.granted,
    a.query,
    a.query_start,
    a.usename
FROM pg_locks l
JOIN pg_stat_activity a ON l.pid = a.pid
ORDER BY l.locktype, l.granted DESC;


SELECT
    a.pid,
    a.wait_event_type,
    a.wait_event,
    a.query,
    a.state
FROM pg_stat_activity a
WHERE a.backend_type LIKE '%logical%'
AND a.wait_event IS NOT NULL;




SELECT
  l.locktype,
  l.mode,
  l.granted,
  l.pid,
  a.usename,
  a.application_name,
  a.client_addr,
  a.backend_start,
  a.query,
  a.state,
  a.wait_event_type,
  a.wait_event
FROM pg_locks l
JOIN pg_class t ON l.relation = t.oid
LEFT JOIN pg_stat_activity a ON l.pid = a.pid
WHERE t.relname = 'claim_core'
  AND t.relnamespace = 'claimsprocess'::regnamespace;



SELECT
    l.locktype,
    l.relation::regclass AS table_name,
    l.mode,
    l.granted,
    a.pid,
    a.usename,
    a.application_name,
    a.client_addr,
    a.state,
    a.query,
    a.query_start,
    a.backend_start
FROM
    pg_locks l
LEFT JOIN pg_stat_activity a ON l.pid = a.pid
LEFT JOIN pg_class c ON l.relation = c.oid
LEFT JOIN pg_namespace n ON c.relnamespace = n.oid
WHERE
    -- Optional: filter by specific table
    c.relname = 'claim_core' AND n.nspname = 'claimsprocess'
    -- If you're not sure about schema, you can skip the schema filter:
    -- c.relname = 'claim_core'
;


SELECT
    pid,
    usename,
    application_name,
    state,
    query,
    query_start,
    now() - query_start AS running_time
FROM pg_stat_activity
WHERE pid = 1038643;


SELECT
  blocked_locks.pid AS blocked_pid,
  blocked_activity.query AS blocked_query,
  blocking_locks.pid AS blocking_pid,
  blocking_activity.query AS blocking_query
FROM pg_locks blocked_locks
JOIN pg_stat_activity blocked_activity
  ON blocked_locks.pid = blocked_activity.pid
JOIN pg_locks blocking_locks
  ON blocked_locks.locktype = blocking_locks.locktype
  AND blocked_locks.database IS NOT DISTINCT FROM blocking_locks.database
  AND blocked_locks.relation IS NOT DISTINCT FROM blocking_locks.relation
  AND blocked_locks.page IS NOT DISTINCT FROM blocking_locks.page
  AND blocked_locks.tuple IS NOT DISTINCT FROM blocking_locks.tuple
  AND blocked_locks.virtualxid IS NOT DISTINCT FROM blocking_locks.virtualxid
  AND blocked_locks.transactionid IS NOT DISTINCT FROM blocking_locks.transactionid
  AND blocked_locks.classid IS NOT DISTINCT FROM blocking_locks.classid
  AND blocked_locks.objid IS NOT DISTINCT FROM blocking_locks.objid
  AND blocked_locks.objsubid IS NOT DISTINCT FROM blocking_locks.objsubid
  AND blocked_locks.pid != blocking_locks.pid
JOIN pg_stat_activity blocking_activity
  ON blocking_locks.pid = blocking_activity.pid
WHERE NOT blocked_locks.granted;


SELECT pid, state, wait_event_type, wait_event, query_start, query
FROM pg_stat_activity
WHERE query ILIKE '%create index%' AND state = 'active';



